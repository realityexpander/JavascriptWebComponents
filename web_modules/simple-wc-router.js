const t=t=>t.includes("/")?"/"===t.charAt(0)?t.substring(1).split("/"):t.split("/"):[t],e=document.createElement.bind(document),o=history.pushState.bind(history),n=history.replaceState.bind(history),s=window.removeEventListener.bind(window),i=window.dispatchEvent.bind(window),r=window.addEventListener.bind(window),u={Router:{NoRoutes:"Router :: No routes were defined!"},RouteMixin:{NoRoute:"RouteMixin :: `navigate` method requires the ### component to have a route property/attribute"}},a=()=>window.location.pathname||"/",c=o=>class extends o{static get properties(){return {routes:Array,route:String,routeProps:Object,routeElement:String,lastRoute:String}}constructor(){super();const t=a();this.routeProps={},this.lastRoute=null,n({route:t},null,t);}connectedCallback(){super.connectedCallback(),r("popstate",this.__handleNav.bind(this)),i(new PopStateEvent("popstate",{state:{route:a()}}));}disconnectedCallback(){super.disconnectedCallback(),s("popstate",this.__handleNav.bind(this));}__handleNav(e){if(!this.constructor.routes)throw u.Router.NoRoutes;const o=e.state.route,n=((e,o)=>{const n=e.find(({path:t})=>t===o);if(n)return {route:n,props:null};const s=e.find(t=>"*"===t.path),i=t(o),r={},u=e.find(({path:e})=>{const o=t(e);if(!Array.isArray(o))return !1;const n=o.filter(t=>!t.includes(":?")).length;return !(o[0].includes(":")||i.length<n||i.length>o.length)&&o.every((t,e)=>o[e].includes(":?")?(r[o[e].replace(":?","")]=i[e],!0):o[e].includes(":")?(r[o[e].replace(":","")]=i[e],!0):t===i[e])});return !u&&s?{route:s}:u||s?{route:u,props:r}:null})(this.constructor.routes,o);n&&(this.route=n.route,this.routeProps=n.props),this.lastRoute!==o&&(this.setRouteElement(),this.lastRoute=o);}setRouteElement(){const t=()=>{let t;"function"==typeof this.route.render?t=this.route.render(this.routeProps):(t=e(this.route.component),Object.assign(t,this.routeProps)),this.routeElement=t;};this.route?customElements.get(this.route.component)||"function"!=typeof this.route.import?t():this.route.import().then(t):this.routeElement=null;}},l=t=>class extends t{static get properties(){return {isRouteActive:Boolean}}connectedCallback(){super.connectedCallback(),this.isRouteActive=this.route===window.location.pathname,r("popstate",this.__handleActive.bind(this));}disconnectedCallback(){super.disconnectedCallback(),s("popstate",this.__handleActive.bind(this));}__handleActive(t){this.isRouteActive=t.state.route===this.route;}navigate(t){const e=t||this.route;if(!e)throw u.RouteMixin.NoRoute.replace("###",this.nodeName);if(e===window.location.pathname)return;if("/"!==e.substring(0,1))return void(window.location.href=e);const n={route:e};o(n,null,e),i(new PopStateEvent("popstate",{state:n}));}};

export { l as RouteMixin, c as Router };
